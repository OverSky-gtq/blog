# 图
## 图的表示形式
![](2022-11-30-15-52-02.png)
对于这样一个图，常见的表示形式有如下两种：
### 邻接矩阵(adjacent matrix)
![](2022-11-30-15-52-21.png)
访问$|V|$个顶点需要$O(|V|)$的时间
查找每个顶点的邻接点都需要$O(|V|)$的时间，而总共有$|V|$个顶点，所以访问所有边的时间复杂度$=O(|V|^2)$
总的时间复杂度$=O(|V|)+O(|V|^2)=O(|V|^2)$
*缺点：矩阵稀疏时很浪费空间*
*代码实现：*
```cpp
typedef int Vertex;
class Graph{
  public:
    Graph(int num){
        num_vertices = num;
        edge = new int*[num_vertices];
        vertexTable = new Vertex[num_vertices];
    }
    ~Graph(){ delete[]vertexTable; delete[]edge; }
  private:
    int num_vertices; //顶点数量
    int **edge;   //邻接矩阵，表示点与点之间是否存在边，有权图中可以当作权值
    Vertex *vertexTable;   //顶点表
};
```

### 邻接表(adjacent list)
![](2022-11-30-15-58-07.png)
访问各个顶点需要$O(|V|)$的时间
有向图查找各个顶点的邻接点共需要$O(|E|)$的时间,无向图则翻倍
总的时间复杂度$=O(|V|+|E|)$
*缺点：不方便找入边和计算入度*
*代码实现：*
```cpp
typedef struct Adjacent_node{
    int dest;  //此邻接(目标)顶点在顶点表中的下标,不能直接使用顶点类，否则会死循环
    int cost;  //顶点与此邻接顶点形成的边上的权值
    Adjacent_node *next;   //下一个邻接顶点
    Adjacent_node(int destination,int weight):dest(destination),cost(weight),next(nullptr){}
} Edge;   //主流命名是“Edge”

struct Vertex{
    int data;    //顶点数据域
    Adjacent_node *first;   //随便一个邻接结点作为边链表头结点
};

class Graph{
  public:
    Graph(int num){
        num_vertices = num;
        num_edges= 0; 
        vertexTable = new Vertex[num_vertices];
    }
    ~Graph(){ delete[]vertexTable; }
  private:
    int num_edges,num_vertices;  //顶点数量、边数量
    Vertex *vertexTable;   //顶点表
};
```
## 图的遍历
### 广度优先遍历(BFS)
![](2022-11-30-19-57-44.png)
添加访问标记数组，可以遍历非连通图
```cpp
bool visited[MaxNumVertex];   //访问标记数组

void BFSTraverse(Graph G) {   //对图G进行广度优先遍历
    for (int i=1; i<=G.num_vertices; ++i) {
        visited[i] = false;   //访问标记数组初始化
    InitQueue(Q);   //初始化辅助队列Q
    for(int i=1; i<=G.num_vertices; ++i)  //从1号顶点开始遍历，遍历过就标记
        if(!visited[i])   //对每个连通分量调用一次BFS,防止多个连通分量之间不连通，永远无法遍历到
            BFS(G,i);   //vi未访问过，从vi开始BFS
    }
}
//广度优先遍历
void BFS(Graph G,int v) {//从顶点v出发，广度优先遍历图G
    visit(v);     //访问初始顶点v
    visited[v]=TRUE;    //对v做已访问标记
    Enqueue(Q,v);    //顶点v入队列Q
    while (!isEmpty(Q)) {
        DeQueue(Q,v);     //顶点v出队列
        for(w=G.FirstNeighbor(v) ; w>=0 ; w=G.NextNeighbor(v,w)){  //检测v所有邻接点
            if(!visited[w]){      //w为v的尚未访问的邻接顶点
                visit(w);  //访问顶点w
                visited[w] = true;  //对w做已访问标记
                EnQueue(Q,w);  //顶点w入队列
            }
        }
    }
}
```
#### 广度优先生成树
连通图按广度优先遍历顺序生成一颗树，若图不连通，则可生成森林
![](2022-11-30-20-05-00.png)
### 深度优先遍历(DFS)
```cpp
bool visited[MaxNumVertex];   //访问标记数组

void DFSTraverse(Graph G){   //对图G进行深度优先遍历
    for(int v=1; v<=G.num_vertices; ++v)
        visited[v]=false;  //初始化已访问标记数据
    for(int v=1; v<=G.num_vertices; ++v)
        if(!visited[v])
            DFS(G,v);
}  //这个函数同样是为了防止出现非连通图

void DFS(Graph G,int v){   //从顶点v出发，深度优先遍历图G
    visit(v);   //访问顶点v
    visited[v] = true;  //设已访问标记
    for(int w=G.FirstNeighbor(v); w>=0; w=G.NextNeighor(v,w))
        if(!visited[w]){   // w为v的尚未访问的邻接顶点
            DFS(G,w);
        }
}
```
对上图进行深度优先遍历，若从2出发，则序列为: 2，1，5，6，3，4，7，8，9，10，11
空间复杂度取决于递归深度，最坏为$O(|V|)$，最好为$O(2)$，最好的情况即其他点围着一个起点。

同一个图的邻接矩阵表示方式*唯一*，因此深度优先遍历序列*唯一*，深度优先生成树也*唯一*。
同一个图邻接表表示方式*不唯一*，因此深度优先遍历序列*不唯一*，深度优先生成树也*不唯一*。
#### 深度优先生成树
定义同BFS，非连通图时生成森林
![](2022-11-30-20-56-04.png)
### 阶段总结
#### 无向图
对无向图进行BFS/DFS遍历，调用BFS/DFS函数的次数=连通分量数
对于连通图，只需调用1次BFS/DFS
#### 有向图
![](2022-11-30-21-04-49.png)
#### 思维导图
![](2022-11-30-21-03-59.png)
![](2022-11-30-21-03-27.png)
## 最小生成树(最小代价树)(Minimum-Spanning-Tree,MST)
![](2022-12-01-19-22-26.png)
+ 非连通图不会产生生成树，只产生生成森林
+ 如果一个连通图本身就是一棵树，则其最小生成树就是它本身
+ 最小生成树*可能不唯一*，但总权值唯一且最小
+ $边数 = 顶点树 - 1$
+ 所以研究对象为**带权连通无向图**

### Prim算法(普里姆)
+ **从某一个顶点开始构建生成树**
+ **每次将靠近*当前生成树*的代价最小的新顶点纳入，直到所有顶点都纳入为止。**
![](2022-12-01-19-36-08.png)
<figure>图中从农场开始，依次是农场、电站、P城、学校、矿场或渔村......</figure>

#### 算法实现
![](2022-12-01-20-04-46.png)
+ 对于这样一个图，准备两个数组，`isJoin`和`lowCost`，初始化如下图
+ 每轮结束后检测*新结点*有没有*带来更小的边*，更新*还没加入生成树*的顶点的`lowCost`，然后接着选择cost最小的新顶点加入
![](2022-12-01-20-05-14.png)
+ 从$V_0$开始，总共需要$n-1$轮处理
+ 每一轮处理:循环遍历所有结点，找到`lowCost`最低的且还没加入树的顶点。
+ 再次循环遍历，更新还没加入的各个顶点的`lowCost`值，每轮$O(2n)$
+ **总时间复杂度为$(n-1)O(n) = O(|V|^2)$，适合用于边稠密的图**

### Kruskal算法(克鲁斯卡尔)
+ **每次选择一条权值最小的边，使这条边的两头连通(若两头已经连通可以互相到达，就不选，去选次小的边)**
+ **直到所有结点都连通**
#### 算法实现
+ 初始︰将各条边按权值排序
![](2022-12-01-20-23-01.png)
![](2022-12-01-20-24-00.png)
+ 共执行$E$轮，每轮判断两个顶点是否属于同一集合，需要$O(log_2E)$
+ **总时间复杂度$O(|E|log_2|E|)$，适合用于边稀疏的图**
## 最短路径问题
### 单源最短路径
#### BFS算法(无权图)
+ 无权图可以看作权都为1的有权图
+ 广度优先生成树的深度其实就是最短路径长度
+ 在广度优先遍历的基础上记录 路径长度`d`和前驱顶点`path`
(`DeQueue(Q,u)`是将队头元素出队并赋值给`u`)
![](2022-12-01-21-14-40.png)
根据`path`数组可以推出最短路线：
![](2022-12-01-21-19-39.png)
#### Dijkstra算法(带权图、无权图)
![](2022-12-01-21-46-09.png)
+ 之前未找到最短路径的顶点中，`dist`最小的顶点本轮可以找到最短路径，将`final[] = true`
+ 尝试经过*新加入的顶点*到*未加入点*，若新的带权路径小于`dist`中的值，则更新`dist`、`path`数组
+ 如此循环，直到`final`数组全部变成`true`
![](2022-12-01-22-21-01.png)
##### 算法实现
![](2022-12-01-22-25-03.png)
这里的`dist`数组的作用类似$Prim$算法中的`lowCost`数组，因此时间复杂度与之相同。
##### 注意
+ $Dijkstra$算法不适用于*带负权*的带权图
+ 原因："`dist`最小的点就找到了最短路径" 这一判断是基于**选择其他路径之后也只会更大**的事实，若有负权，则这一事实不成立
### 各顶点间的最短路径
一个显然的思路是：轮流以每一个顶点作为源点，重复执行$Dijkstra$算法$n$次，时间复杂度为$O(n^3)$

下面介绍一种形式上更直接的$Floyd$算法，虽然时间复杂度也是$O(n^3)$
#### Floyd算法(带(负)权图、无权图)
带有*负权回路*还是不能解决
##### 思路
![](2022-12-01-22-45-12.png)
##### 实现逻辑
![](2022-12-01-23-04-29.png)
+ 不断更新两个状态矩阵，右上角标代表第几轮
+ 若通过第$k$个中转点可以减少路径，则更新矩阵
###### 一个更复杂的例子
*状态1*
![](2022-12-01-23-25-48.png)
*状态2*
![](2022-12-01-23-27-09.png)
......后面同理
##### 代码展示
```cpp
//......准备工作，根据图的信息初始化矩阵A和path(如上图)
for (int k=0 ; k<n; k++) {  //考虑以V_k作为中转点
    for (int i=0; i<n; i++) {  //遍历整个矩阵，i为行号，j为列号
        for (int j=0; j<n; j++) {
            if (A[i][j] > A[i][k] + A[k][j]) {//以 V_k为中转点的路径更短
                A[i][j] = A[i][k] + A[k][j];  //更新最短路径长度
                path[i][j] = k;  //中转点
            }
        }
    }
}
```
##### 复原完整路线
通过递归填充两点间的路径
![](2022-12-01-23-19-33.png)
### 阶段总结
![](2022-12-01-23-31-42.png)